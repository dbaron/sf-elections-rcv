<!DOCTYPE HTML>
<meta charset=UTF-8>
<title>Election Results, San Francisco, June 2018</title>
<style>

body { background: white; color: black; }

table.rcv_results { border-collapse: collapse; border-width: 2px; }
table.rcv_results > tbody > tr > td.leader { background: #bfb; }
table.rcv_results > tbody > tr > td.winner { background: #7f7; }

table.rcv_results > tbody > tr > td,
table.rcv_results > tbody > tr > th { border: 1px solid black }
table.rcv_results > tbody > tr > td.votes { border-left-width: 2px; border-right-color: gray; }
table.rcv_results > tbody > tr > td.percent { border-right-width: 2px; border-left-color: gray; }
table.rcv_results > tbody > tr > th.total { border-left-width: 2px; border-right-width: 2px; }

div.filter {
    display: inline-block;
    vertical-align: top;
    margin: 0.5em;
    padding: 0.5em;
    border: 1px solid;
}

div.filter > label { display: block }

</style>
<script>
'use strict';

var gDefaults = {
    election: "20180606",
    filters: [],
};
function gethash() {
    var hash = {};
    if (window.location.hash != "") {
        try {
            hash = JSON.parse(unescape(window.location.hash.substring(1)));
        } catch(ex) {}
    }
    for (var prop in gDefaults) {
        if (!(prop in hash)) {
            hash[prop] = gDefaults[prop];
        }
    }
    return hash;
}

function sethash(json) {
    let newhash = escape(JSON.stringify(json));
    if (window.location.hash != newhash) {
        window.location.hash = newhash;
    }
}

var gState;

function dom_load_handler() {
    gState = gethash();

    let elections_select = document.getElementById("election");
    for (let election of ELECTIONS) {
        let option = document.createElement("option");
        option.textContent = election.name;
        option.setAttribute("value", election.id);
        elections_select.appendChild(option);
    }
    elections_select.value = gState.election;
    elections_select.addEventListener("change", function(event) {
        if (should_suppress_change(elections_select)) {
            return;
        }
        gState.election = elections_select.value;
        state_changed();
    });

    let contest_select = document.getElementById("contest");
    contest_select.addEventListener("change", function(event) {
        if (should_suppress_change(contest_select)) {
            return;
        }
        gState.contest = contest_select.value;
        state_changed();
    });

    hashchange_listener();
}

function hashchange_listener() {
    gState = gethash();
    sethash(gState);
    update_ui();
}

function state_changed() {
    sethash(gState);
    update_ui();
}

window.addEventListener("DOMContentLoaded", dom_load_handler);
window.addEventListener("hashchange", hashchange_listener);

let ELECTIONS = [
  { name: "June 5, 2018 Election, Preliminary Report 5",
    id: "20180606" },
  { name: "June 5, 2018 Election, Preliminary Report 4",
    id: "20180605_4" },
  { name: "June 5, 2018 Election, Preliminary Report 1",
    id: "20180605_1" },
  { name: "November 8, 2016 Election, Final Report",
    id: "20161206" },
  { name: "November 3, 2015 Election, Final Report",
    id: "20151119" },
  { name: "November 4, 2014 Election, Final Report",
    id: "20141104" /* my ID, not the Department of Elections */ },
];

function get_current_election() {
    return ELECTIONS.find((election) => election.id == gState.election);
}

function* generate_lines(str)
{
    let index = 0;
    while (true) {
        let next = str.indexOf("\n", index);
        if (next == -1) {
            break;
        }
        yield str.slice(index, next);
        index = next + 1;
    }
    return str.slice(index);
}

function read_fields(election_id)
{
    return fetch(new Request(`data/${election_id}_masterlookup.txt`)).then(function(response) {
        return response.text();
    }).then(function(text) {
        let fields = {};
        for (let line of generate_lines(text)) {
            let type = line.slice(0, 10).trimEnd();
            let id = line.slice(10, 17);
            let name = line.slice(17, 67).trimEnd();
            let order = line.slice(67, 74);
            let candidate_contest = line.slice(74, 81);
            let writein = line.slice(81, 82);
            let provisional = line.slice(82, 83);
            if (!(type in fields)) {
                fields[type] = {};
            }
            let field = fields[type];
            if (type == "Candidate") {
                field[id] = { name, order, contest: candidate_contest, writein }
            } else {
                if (candidate_contest != "0000000") {
                    console.log("unexpected candidate_contest", line, candidate_contest);
                }
                if (writein != "0") {
                    console.log("unexpected writein", line, writein);
                }
                field[id] = { name, order }
            }
            if (provisional != "0") {
                console.log("unexpected provisional", line, provisional);
            }
        }
        return fields;
    });
}

function read_ballots(election_id) {
    return fetch(new Request(`data/${election_id}_ballotimage.txt`)).then(function(response) {
        return response.text();
    }).then(function(text) {
        function* generate_ballot_singles(text) {
            for (let line of generate_lines(text)) {
                let contest = line.slice(0, 7);
                let voter = line.slice(7, 16);
                let machine_serial_number = line.slice(16, 23);
                let tally_type = line.slice(23, 26);
                let precinct = line.slice(26, 33);
                let vote_rank = line.slice(33, 36);
                let candidate = line.slice(36, 43);
                let overvote = line.slice(43, 44);
                let undervote = line.slice(44, 45);
                yield {contest, voter, machine_serial_number, tally_type, precinct,
                       vote_rank, candidate, overvote, undervote};
            }
        }
        function* generate_ballot_triples(text) {
            // Assume that the data file has the three ranks for each ballot in order,
            // and report errors if that's not the case, since we don't handle it.
            let gen = generate_ballot_singles(text);
            while (true) {
                let b1 = gen.next();
                let b2 = gen.next();
                let b3 = gen.next();
                if (b1.done) {
                    return;
                }
                if (b3.done) {
                    // These exceptions don't produce useful diagnostics (nothing on console)!
                    console.log("last triple truncated");
                    throw "bad ballot data: last triple truncated";
                }
                b1 = b1.value;
                b2 = b2.value;
                b3 = b3.value;
                const common_props = [ "contest", "voter", "machine_serial_number", "tally_type", "precinct" ];
                let ballot = {};
                for (let prop of common_props) {
                    if (b1[prop] != b2[prop] || b1[prop] != b3[prop]) {
                        // These exceptions don't produce useful diagnostics (nothing on console)!
                        console.log("inconsistent data within ballot");
                        throw "inconsistent data within ballot";
                    }
                    ballot[prop] = b1[prop];
                }
                if (b1.vote_rank != "001" || b2.vote_rank != "002" || b3.vote_rank != "003") {
                    // These exceptions don't produce useful diagnostics (nothing on console)!
                    console.log("ranks throwing", b1.vote_rank, b2.vote_rank, b3.vote_rank);
                    throw "ballot not ranked properly";
                }
                ballot.ranks = [b1, b2, b3].map(b => ({ candidate: b.candidate,
                                                        overvote:  b.overvote,
                                                        undervote: b.undervote }));
                yield ballot;
            }
        }
        return Array.from(generate_ballot_triples(text));
    });
}

function start_needed_loads(election)
{
    if (!("fields" in election)) {
        election.fields = "loading";
        read_fields(election.id).then(function(fields) { election.fields = fields; update_ui(); }).catch(function(error) { console.log(error); delete election.fields; });
    }

    if (!("ballots" in election)) {
        election.ballots = "loading";
        read_ballots(election.id).then(function(ballots) { election.ballots = ballots; update_ui(); }).catch(function(error) { console.log(error); delete election.ballots; });
    }
}

function set_suppress_change(select_element, do_suppress) {
    if (do_suppress) {
        select_element.setAttribute("data-suppress-change", "true");
    } else {
        select_element.removeAttribute("data-suppress-change");
    }
}

function should_suppress_change(select_element) {
    return select_element.hasAttribute("data-suppress-change");
}

function precinct_to_sup_district(precinct_id, fields)
{
    let precinct = fields["Precinct"][precinct_id].name;

    if (!(/^Pct [0-9]{4}/.exec(precinct))) {
        throw `Unexpected precinct: ${precinct}`;
    }
    precinct = precinct.slice(4);
    if (precinct[0] == "7" || precinct[0] == "9") {
        if (precinct[1] == 0) {
            return "10";
        }
        return precinct[1];
    }
    if (precinct[0] == "1" && precinct[1] == "1") {
        return "11";
    }
    throw `Unexpected precinct: ${precinct}`;
}

function update_ui() {
    let election = get_current_election();

    let elections_select = document.getElementById("election");
    if (elections_select.value != election.id) {
        set_suppress_change(elections_select, true);
        elections_select.value = election.id;
        set_suppress_change(elections_select, false);
    }

    start_needed_loads(election);

    let output = document.getElementById("output");
    let contest_select = document.getElementById("contest");

    if (election.fields == "loading" || election.ballots == "loading") {
        output.textContent = "Loading...";

        set_suppress_change(contest_select, true);
        contest_select.textContent = "";
        let contest_option = document.createElement("option");
        contest_option.textContent = "Loading...";
        contest_select.appendChild(contest_option);
        contest_select.removeAttribute("data-election");
        set_suppress_change(contest_select, false);

        return;
    }

    if (contest_select.getAttribute("data-election") != election.id) {
        contest_select.setAttribute("data-election", election.id);
        set_suppress_change(contest_select, true);
        contest_select.textContent = "";
        let contests = election.fields["Contest"];
        let found = false;
        for (let contest in contests) {
            let contest_option = document.createElement("option");
            contest_option.textContent = contests[contest].name;
            contest_option.value = contest;
            if (contest == gState.contest) {
                found = true;
            }
            contest_select.appendChild(contest_option);
        }
        if (!found) {
            gState.contest = Object.keys(contests)[0];
        }
        contest_select.value = gState.contest;
        set_suppress_change(contest_select, false);
    }

    let contest = contest_select.value;

    let sup_districts = {};
    let tally_types = {};
    for (let ballot of election.ballots) {
        if (ballot.contest != contest) {
            continue;
        }
        let district = precinct_to_sup_district(ballot.precinct, election.fields);
        if (!(district in sup_districts)) {
            sup_districts[district] = 0;
        }
        ++sup_districts[district];
        let tally_type = ballot.tally_type;
        if (!(tally_type in tally_types)) {
            tally_types[tally_type] = 0;
        }
        ++tally_types[tally_type];
    }

    let contest_candidates = Object.entries(election.fields["Candidate"]).filter(([id, candidate]) => candidate.contest == contest).reduce((o, [id, candidate]) => ({ ...o, [id]: {...candidate, id}}), {});
    // .map(([id, candidate]) => Object.assign({id}, candidate));
    let candidates_remaining = Object.assign({}, contest_candidates);
    let candidates_ranked = [];
    let rounds = [];
    while (Object.keys(candidates_remaining).length > 1) {
        let round = Object.keys(candidates_remaining).reduce((o, id) => ({...o, [id]: 0}), {});
        for (let ballot of election.ballots) {
            for (let rank of ballot.ranks) {
                if (rank.overvote == "1") {
                    // Discard overvotes, even if a later rank of the ballot is good.
                    // Allow undervotes to fall back to later ranks.
                    // This produces results that match the official results.
                    break;
                }
                if (rank.candidate in round) {
                    ++round[rank.candidate];
                    break;
                }
            }
        }
        let lowest_total = Math.min(...Object.values(round));
        // FIXME: This probably isn't right for multiple candidates being eliminated,
        // especially if it eliminates the last one.
        for (let id in candidates_remaining) {
            if (round[id] == lowest_total) {
                candidates_ranked.push(Object.assign({id}, candidates_remaining[id]));
                delete candidates_remaining[id];
            }
        }
        rounds.push(round);
    }
    candidates_ranked.push(Object.entries(candidates_remaining).map(([id, candidate]) => Object.assign({id}, candidate))[0]);
    candidates_ranked.reverse();

    let table = make_rcv_table(candidates_ranked, rounds);
    output.textContent = "";
    output.appendChild(table);

    let filter_container = document.createElement("div");

    let make_filter = (name, set_id, choices) => {
        let filter_div = document.createElement("div");
        filter_div.classList.add("filter");
        filter_div.setAttribute("data-filter", set_id);
        filter_div.appendChild(document.createTextNode(`Filter: ${name}`));

        for (let choice of choices) {
            let label = document.createElement("label");
            let checkbox = document.createElement("input");
            checkbox.setAttribute("type", "checkbox");
            let item_id = `${set_id}-${choice.id}`;
            if (gState.filters.indexOf(item_id) == -1) {
                checkbox.setAttribute("checked", "");
            }
            checkbox.addEventListener("change", (event) => {
                if (checkbox.checked) {
                    let index = gState.filters.indexOf(item_id);
                    if (index == -1) {
                        console.log(`Unexpectedly couldn't find filter ${item_id}.`);
                    } else {
                        gState.filters.splice(index, 1);
                        state_changed();
                    }
                } else {
                    gState.filters.push(item_id);
                    state_changed();
                }
            });
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(choice.name));
            filter_div.appendChild(label);
        }
        filter_container.appendChild(filter_div);
    };

    make_filter("Supervisor District", "district", Object.entries(sup_districts).map(([district, count]) => ({ num: Number(district), id: `d${district}`, name: `District ${district} (${count})` })).sort((a, b) => a.num - b.num));
    make_filter("Tally Type", "tally_type", Object.entries(tally_types).map(([tally_type, count]) => ({ id: tally_type, name: `${election.fields["Tally Type"]["0000" + tally_type].name} (${count})` })));
    make_filter("Remove Candidates", "candidate", Object.values(contest_candidates).map((candidate) => ({ id: candidate.id, name: candidate.name, order: Number(candidate.order)})).sort((a, b) => a.order - b.order));

    output.appendChild(filter_container);
}

function make_cell(tag_name, text)
{
    let cell = document.createElement(tag_name);
    cell.textContent = text;
    return cell;
}

function make_rcv_table(candidates_ranked, rounds)
{
    let rounds_data = rounds.map(round => {
        let max = 0;
        let sum = 0;
        for (let votes of Object.values(round)) {
            if (votes > max) {
                max = votes;
            }
            sum += votes;
        }
        return {max, sum};
    });

    let table = document.createElement("table");
    table.classList.add("rcv_results");
    let tbody = document.createElement("tbody");
    table.appendChild(tbody);
    for (let candidate of candidates_ranked) {
        let tr = document.createElement("tr");
        tbody.appendChild(tr);
        let candidate_th = make_cell("th", candidate.name);
        candidate_th.classList.add("candidate");
        tr.appendChild(candidate_th);
        for (let round_index in rounds) {
            let round = rounds[round_index];
            let round_data = rounds_data[round_index];
            let text;
            let votes = 0;
            let in_round = candidate.id in round;
            if (in_round) {
                votes = round[candidate.id];
                text = "" + votes;
            } else {
                text = "";
            }
            let votes_cell = make_cell("td", text);
            let pct_cell = make_cell("td", in_round ? (Math.round(votes / round_data.sum * 10000) / 100) + "%" : "");
            if (votes * 2 > round_data.sum) {
                votes_cell.classList.add("winner");
                pct_cell.classList.add("winner");
            } else if (votes == round_data.max) {
                votes_cell.classList.add("leader");
                pct_cell.classList.add("leader");
            }
            votes_cell.classList.add("votes");
            pct_cell.classList.add("percent");
            tr.appendChild(votes_cell);
            tr.appendChild(pct_cell);
        }
    }
    let tr_sum = document.createElement("tr");
    tbody.appendChild(tr_sum);
    tr_sum.appendChild(make_cell("th", "Total"));
    for (let round_data of rounds_data) {
        let total_cell = make_cell("th", "" + round_data.sum);
        total_cell.classList.add("total");
        total_cell.setAttribute("colspan", "2");
        tr_sum.appendChild(total_cell);
    }

    return table;
}

</script>

<body>

<select id="election"></select>
<select id="contest"></select>

<div id="output"></div>

<p>(<a href="https://github.com/dbaron/sf-elections-rcv">source on GitHub</a>)</p>
