<!DOCTYPE HTML>
<meta charset=UTF-8>
<title>Election Results, San Francisco, June 2018</title>
<style>

body { background: white; color: black; }

table.rcv_results { border-collapse: collapse; border-width: 2px; }
table.rcv_results > tbody > tr > td.leader { background: #bfb; }
table.rcv_results > tbody > tr > td.winner { background: #7f7; }

table.rcv_results > tbody > tr > td,
table.rcv_results > tbody > tr > th { border: 1px solid black }
table.rcv_results > tbody > tr > td.votes { border-left-width: 2px; border-right-color: gray; }
table.rcv_results > tbody > tr > td.percent { border-right-width: 2px; border-left-color: gray; }
table.rcv_results > tbody > tr > th.total { border-left-width: 2px; border-right-width: 2px; }

</style>
<script>
'use strict';

var gDefaults = {
    election: "20180605_4",
};
function gethash() {
    var hash = {};
    if (window.location.hash != "") {
        try {
            hash = JSON.parse(unescape(window.location.hash.substring(1)));
        } catch(ex) {}
    }
    for (var prop in gDefaults) {
        if (!(prop in hash)) {
            hash[prop] = gDefaults[prop];
        }
    }
    return hash;
}

function sethash(json) {
    let newhash = escape(JSON.stringify(json));
    if (window.location.hash != newhash) {
        window.location.hash = newhash;
    }
}

var gState;

function dom_load_handler() {
    hashchange_listener();
}

function hashchange_listener() {
    gState = gethash();
    sethash(gState);
    update_ui();
}

window.addEventListener("DOMContentLoaded", dom_load_handler);
window.addEventListener("hashchange", hashchange_listener);

let ELECTIONS = [
  { name: "June 5, 2018 Election, Preliminary Report 4",
    id: "20180605_4" },
  { name: "June 5, 2018 Election, Preliminary Report 1",
    id: "20180605_1" },
].reduce((obj, entry) => ({...obj, [entry.id]:entry}), {});

function get_current_election() {
    return ELECTIONS[gState.election];
}

function* generate_lines(str)
{
    let index = 0;
    while (true) {
        let next = str.indexOf("\n", index);
        if (next == -1) {
            break;
        }
        yield str.slice(index, next);
        index = next + 1;
    }
    return str.slice(index);
}

function read_fields(election_id)
{
    return fetch(new Request(`data/${election_id}_masterlookup.txt`)).then(function(response) {
        return response.text();
    }).then(function(text) {
        let fields = {};
        for (let line of generate_lines(text)) {
            let type = line.slice(0, 10).trimEnd();
            let id = line.slice(10, 17);
            let name = line.slice(17, 67).trimEnd();
            let order = line.slice(67, 74);
            let candidate_contest = line.slice(74, 81);
            let writein = line.slice(81, 82);
            let provisional = line.slice(82, 83);
            if (!(type in fields)) {
                fields[type] = {};
            }
            let field = fields[type];
            if (type == "Candidate") {
                field[id] = { name, order, contest: candidate_contest, writein }
            } else {
                if (candidate_contest != "0000000") {
                    console.log("unexpected candidate_contest", line, candidate_contest);
                }
                if (writein != "0") {
                    console.log("unexpected writein", line, writein);
                }
                field[id] = { name, order }
            }
            if (provisional != "0") {
                console.log("unexpected provisional", line, provisional);
            }
        }
        return fields;
    });
}

function read_ballots(election_id) {
    return fetch(new Request(`data/${election_id}_ballotimage.txt`)).then(function(response) {
        return response.text();
    }).then(function(text) {
        function* generate_ballot_singles(text) {
            for (let line of generate_lines(text)) {
                let contest = line.slice(0, 7);
                let voter = line.slice(7, 16);
                let machine_serial_number = line.slice(16, 23);
                let tally_type = line.slice(23, 26);
                let precinct = line.slice(26, 33);
                let vote_rank = line.slice(33, 36);
                let candidate = line.slice(36, 43);
                let overvote = line.slice(43, 44);
                let undervote = line.slice(44, 45);
                yield {contest, voter, machine_serial_number, tally_type, precinct,
                       vote_rank, candidate, overvote, undervote};
            }
        }
        function* generate_ballot_triples(text) {
            // Assume that the data file has the three ranks for each ballot in order,
            // and report errors if that's not the case, since we don't handle it.
            let gen = generate_ballot_singles(text);
            while (true) {
                let b1 = gen.next();
                let b2 = gen.next();
                let b3 = gen.next();
                if (b1.done) {
                    return;
                }
                if (b3.done) {
                    // These exceptions don't produce useful diagnostics (nothing on console)!
                    console.log("last triple truncated");
                    throw "bad ballot data: last triple truncated";
                }
                b1 = b1.value;
                b2 = b2.value;
                b3 = b3.value;
                const common_props = [ "contest", "voter", "machine_serial_number", "tally_type", "precinct" ];
                let ballot = {};
                for (let prop of common_props) {
                    if (b1[prop] != b2[prop] || b1[prop] != b3[prop]) {
                        // These exceptions don't produce useful diagnostics (nothing on console)!
                        console.log("inconsistent data within ballot");
                        throw "inconsistent data within ballot";
                    }
                    ballot[prop] = b1[prop];
                }
                if (b1.vote_rank != "001" || b2.vote_rank != "002" || b3.vote_rank != "003") {
                    // These exceptions don't produce useful diagnostics (nothing on console)!
                    console.log("ranks throwing", b1.vote_rank, b2.vote_rank, b3.vote_rank);
                    throw "ballot not ranked properly";
                }
                ballot.ranks = [b1, b2, b3].map(b => ({ candidate: b.candidate,
                                                        overvote:  b.overvote,
                                                        undervote: b.undervote }));
                yield ballot;
            }
        }
        return Array.from(generate_ballot_triples(text));
    });
}

function start_needed_loads(election)
{
    if (!("fields" in election)) {
        election.fields = "loading";
        read_fields(election.id).then(function(fields) { election.fields = fields; update_ui(); }).catch(function(error) { console.log(error); delete election.fields; });
    }

    if (!("ballots" in election)) {
        election.ballots = "loading";
        read_ballots(election.id).then(function(ballots) { election.ballots = ballots; update_ui(); }).catch(function(error) { console.log(error); delete election.ballots; });
    }
}

function update_ui() {
    let election = get_current_election();
    start_needed_loads(election);

    let output = document.getElementById("output");

    if (election.fields == "loading" || election.ballots == "loading") {
        output.textContent = "Loading...";
        return;
    }

    // FIXME: Add ability to choose.
    let contest = "0000020";

    let contest_name = election.fields["Contest"][contest];

    let candidates_remaining = Object.entries(election.fields["Candidate"]).filter(([id, candidate]) => candidate.contest == contest).reduce((o, [id, candidate]) => ({ ...o, [id]: candidate}), {});
    // .map(([id, candidate]) => Object.assign({id}, candidate));
    let candidates_ranked = [];
    let rounds = [];
    while (Object.keys(candidates_remaining).length > 1) {
        let round = Object.keys(candidates_remaining).reduce((o, id) => ({...o, [id]: 0}), {});
        for (let ballot of election.ballots) {
            for (let rank of ballot.ranks) {
                if (rank.overvote == "1") {
                    // Discard overvotes, even if a later rank of the ballot is good.
                    // Allow undervotes to fall back to later ranks.
                    // This produces results that match the official results.
                    break;
                }
                if (rank.candidate in round) {
                    ++round[rank.candidate];
                    break;
                }
            }
        }
        let lowest_total = Math.min(...Object.values(round));
        // FIXME: This probably isn't right for multiple candidates being eliminated,
        // especially if it eliminates the last one.
        for (let id in candidates_remaining) {
            if (round[id] == lowest_total) {
                candidates_ranked.push(Object.assign({id}, candidates_remaining[id]));
                delete candidates_remaining[id];
            }
        }
        rounds.push(round);
    }
    candidates_ranked.push(Object.entries(candidates_remaining).map(([id, candidate]) => Object.assign({id}, candidate))[0]);
    candidates_ranked.reverse();

    let table = make_rcv_table(candidates_ranked, rounds);
    output.textContent = "";
    output.appendChild(table);
}

function make_cell(tag_name, text)
{
    let cell = document.createElement(tag_name);
    cell.textContent = text;
    return cell;
}

function make_rcv_table(candidates_ranked, rounds)
{
    let rounds_data = rounds.map(round => {
        let max = 0;
        let sum = 0;
        for (let votes of Object.values(round)) {
            if (votes > max) {
                max = votes;
            }
            sum += votes;
        }
        return {max, sum};
    });

    let table = document.createElement("table");
    table.classList.add("rcv_results");
    let tbody = document.createElement("tbody");
    table.appendChild(tbody);
    for (let candidate of candidates_ranked) {
        let tr = document.createElement("tr");
        tbody.appendChild(tr);
        tr.appendChild(make_cell("th", candidate.name));
        for (let round_index in rounds) {
            let round = rounds[round_index];
            let round_data = rounds_data[round_index];
            let text;
            let votes = 0;
            let in_round = candidate.id in round;
            if (in_round) {
                votes = round[candidate.id];
                text = "" + votes;
            } else {
                text = "";
            }
            let votes_cell = make_cell("td", text);
            let pct_cell = make_cell("td", in_round ? (Math.round(votes / round_data.sum * 10000) / 100) + "%" : "");
            if (votes * 2 > round_data.sum) {
                votes_cell.classList.add("winner");
                pct_cell.classList.add("winner");
            } else if (votes == round_data.max) {
                votes_cell.classList.add("leader");
                pct_cell.classList.add("leader");
            }
            votes_cell.classList.add("votes");
            pct_cell.classList.add("percent");
            tr.appendChild(votes_cell);
            tr.appendChild(pct_cell);
        }
    }
    let tr_sum = document.createElement("tr");
    tbody.appendChild(tr_sum);
    tr_sum.appendChild(make_cell("th", "Total"));
    for (let round_data of rounds_data) {
        let total_cell = make_cell("th", "" + round_data.sum);
        total_cell.classList.add("total");
        total_cell.setAttribute("colspan", "2");
        tr_sum.appendChild(total_cell);
    }

    return table;
}

</script>

<body>

<div id="output"></div>
